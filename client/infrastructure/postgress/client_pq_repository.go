package postgres

import (
	clientDomain "github.com/harold2111/loans/client/domain"
	"github.com/harold2111/loans/shared/errors"

	"github.com/jinzhu/gorm"
	"github.com/lib/pq"
)

type clientRepository struct {
	db *gorm.DB
}

const (
	uniqueConstraintIdentification = "uix_clients_identification"
)

// NewClientRepository returns a new instance of a Postgres client repository.
func NewClientRepository(db *gorm.DB) (clientDomain.ClientRepository, error) {
	r := &clientRepository{
		db: db,
	}
	return r, nil
}

func (r *clientRepository) FindAll() ([]clientDomain.Client, error) {
	var clients []clientDomain.Client
	response := r.db.Find(&clients)
	if error := response.Error; error != nil {
		return nil, error
	}
	return clients, nil
}

func (r *clientRepository) Find(clientID uint) (clientDomain.Client, error) {
	var client clientDomain.Client
	response := r.db.Preload("Addresses").First(&client, clientID)
	if error := response.Error; error != nil {
		if response.RecordNotFound() {
			messagesParameters := []interface{}{clientID}
			return client, &errors.RecordNotFound{ErrorCode: errors.ClientNotExist, MessagesParameters: messagesParameters}
		}
		return client, error
	}
	return client, nil
}

func (r *clientRepository) Create(client *clientDomain.Client) error {
	client.ID = 0 //autogenerated
	for index := 0; index < len(client.Addresses); index++ {
		client.Addresses[index].ID = 0 //autogenerated
	}
	error := r.db.Create(client).Error
	if error != nil {
		if isUniqueConstraintError(error, uniqueConstraintIdentification) {
			messagesParameters := []interface{}{client.Identification}
			return &errors.GracefulError{ErrorCode: errors.IdentificationDuplicate, MessagesParameters: messagesParameters}
		}
	}
	return error
}

func (r *clientRepository) Update(client *clientDomain.Client) error {
	tx := r.db.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()
	if err := tx.Error; err != nil {
		return err
	}
	if err := tx.Delete(clientDomain.Address{}, "client_id = ?", client.ID).Error; err != nil {
		tx.Rollback()
		return err
	}
	if err := tx.Save(client).Error; err != nil {
		tx.Rollback()
		if isUniqueConstraintError(err, uniqueConstraintIdentification) {
			messagesParameters := []interface{}{client.Identification}
			return &errors.GracefulError{ErrorCode: errors.IdentificationDuplicate, MessagesParameters: messagesParameters}
		}
		return err
	}
	return tx.Commit().Error
}

func (r *clientRepository) Delete(client *clientDomain.Client) error {
	if err := r.db.Delete(client).Error; err != nil {
		return err
	}
	return nil
}

func isUniqueConstraintError(err error, constraintName string) bool {
	if pqErr, ok := err.(*pq.Error); ok {
		return pqErr.Code == "23505" && pqErr.Constraint == constraintName
	}
	return false
}
