package postgres

import (
	clientDomain "loans/client/domain"
	"loans/shared/errors"

	"github.com/jinzhu/gorm"
	"github.com/lib/pq"
)

type clientRepository struct {
	db *gorm.DB
}

const (
	uniqueConstraintIdentification = "uix_clients_identification"
)

// NewClientRepository returns a new instance of a Postgres client repository.
func NewClientRepository(db *gorm.DB) (clientDomain.ClientRepository, error) {
	r := &clientRepository{
		db: db,
	}
	return r, nil
}

func (r *clientRepository) FindAll() ([]clientDomain.Client, error) {
	var clients []clientDomain.Client
	response := r.db.Find(&clients)
	if error := response.Error; error != nil {
		return nil, error
	}
	return clients, nil
}

func (r *clientRepository) Find(clientID uint) (clientDomain.Client, error) {
	var client clientDomain.Client
	response := r.db.Preload("Addresses").First(&client, clientID)
	if error := response.Error; error != nil {
		if response.RecordNotFound() {
			messagesParameters := []interface{}{clientID}
			return client, &errors.RecordNotFound{ErrorCode: errors.ClientNotExist, MessagesParameters: messagesParameters}
		}
		return client, error
	}
	return client, nil
}

func (r *clientRepository) Create(client *clientDomain.Client) error {
	client.ID = 0 //autogenerated
	for index := 0; index < len(client.Addresses); index++ {
		client.Addresses[index].ID = 0 //autogenerated
	}
	error := r.db.Create(client).Error
	if error != nil {
		if isUniqueConstraintError(error, uniqueConstraintIdentification) {
			messagesParameters := []interface{}{client.Identification}
			return &errors.GracefulError{ErrorCode: errors.IdentificationDuplicate, MessagesParameters: messagesParameters}
		}
	}
	return error
}

func (r *clientRepository) Update(client *clientDomain.Client) error {
	client.Addresses = nil
	if err := r.db.Save(client).Error; err != nil {
		if isUniqueConstraintError(err, uniqueConstraintIdentification) {
			messagesParameters := []interface{}{client.Identification}
			return &errors.GracefulError{ErrorCode: errors.IdentificationDuplicate, MessagesParameters: messagesParameters}
		}
	}
	return nil
}

func (r *clientRepository) Delete(client *clientDomain.Client) error {
	if err := r.db.Delete(client).Error; err != nil {
		return err
	}
	return nil
}

func (r *clientRepository) FindAddressesByClientID(clientID uint) ([]clientDomain.Address, error) {
	var addresses []clientDomain.Address
	response := r.db.Find(&addresses, "client_id = ?", clientID)
	if error := response.Error; error != nil {
		if response.RecordNotFound() {
			messagesParameters := []interface{}{clientID}
			return nil, &errors.RecordNotFound{ErrorCode: errors.ClientNotAddressFound, MessagesParameters: messagesParameters}
		}
		return nil, error
	}
	return addresses, nil
}

func (r *clientRepository) FindAddressByIDAndClientID(addressID uint, ClientID uint) (*clientDomain.Address, error) {
	var address clientDomain.Address
	response := r.db.Where("id = ? AND client_id = ?", addressID, ClientID).First(&address)
	if error := response.Error; error != nil {
		if response.RecordNotFound() {
			messagesParameters := []interface{}{addressID}
			return &address, &errors.RecordNotFound{ErrorCode: errors.AddressNotExist, MessagesParameters: messagesParameters}
		}
		return &address, error
	}
	return &address, nil

}

func (r *clientRepository) CreateAddressClient(address *clientDomain.Address) error {
	address.ID = 0 //autogenerated
	if err := r.db.Create(address).Error; err != nil {
		return err
	}
	return nil
}

func (r *clientRepository) UpdateAddressClient(address *clientDomain.Address) error {
	if err := r.db.Save(address).Error; err != nil {
		return err
	}
	return nil
}

func (r *clientRepository) DeleteAddressClient(address *clientDomain.Address) error {
	if err := r.db.Delete(address).Error; err != nil {
		return err
	}
	return nil
}

func isUniqueConstraintError(err error, constraintName string) bool {
	if pqErr, ok := err.(*pq.Error); ok {
		return pqErr.Code == "23505" && pqErr.Constraint == constraintName
	}
	return false
}
